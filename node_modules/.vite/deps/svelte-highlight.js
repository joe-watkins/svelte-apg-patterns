import "./chunk-6A2TAOKG.js";
import {
  core_default
} from "./chunk-NYMCTV5N.js";
import {
  es_default
} from "./chunk-JK72PB2R.js";
import "./chunk-BHYE3OUV.js";
import {
  xml
} from "./chunk-WHFP4LVP.js";
import {
  javascript
} from "./chunk-7F4DVVDX.js";
import {
  css
} from "./chunk-K34KHFZ3.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_style,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-UJLIVLOQ.js";
import "./chunk-DFKQJ226.js";

// node_modules/svelte-highlight/LangTag.svelte
var file = "node_modules/svelte-highlight/LangTag.svelte";
function add_css(target) {
  append_styles(target, "svelte-11sh29b", ".langtag.svelte-11sh29b{position:relative}.langtag.svelte-11sh29b::after{content:attr(data-language);position:absolute;top:0;right:0;padding:1em;display:flex;align-items:center;justify-content:center;background:var(--langtag-background, inherit);color:var(--langtag-color, inherit);border-radius:var(--langtag-border-radius)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGFuZ1RhZy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBY0UsdUJBQVMsQ0FDUCxRQUFRLENBQUUsUUFDWixDQUVBLHVCQUFRLE9BQVEsQ0FDZCxPQUFPLENBQUUsS0FBSyxhQUFhLENBQUMsQ0FDNUIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixLQUFLLENBQUUsQ0FBQyxDQUNSLE9BQU8sQ0FBRSxHQUFHLENBQ1osT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FDOUMsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUNwQyxhQUFhLENBQUUsSUFBSSx1QkFBdUIsQ0FDNUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTGFuZ1RhZy5zdmVsdGUiXX0= */");
}
function create_else_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*code*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*code*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*code*/
      4)
        set_data_dev(
          t,
          /*code*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(11:41) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*highlighted*/
        ctx[1],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*highlighted*/
      2)
        html_tag.p(
          /*highlighted*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(11:5) {#if highlighted}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let pre;
  let code_1;
  function select_block_type(ctx2, dirty) {
    if (
      /*highlighted*/
      ctx2[1]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let pre_levels = [
    { "data-language": (
      /*languageName*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let pre_data = {};
  for (let i = 0; i < pre_levels.length; i += 1) {
    pre_data = assign(pre_data, pre_levels[i]);
  }
  const block = {
    c: function create() {
      pre = element("pre");
      code_1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { "data-language": true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", {});
      var code_1_nodes = children(code_1);
      if_block.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(code_1, "hljs", true);
      add_location(code_1, file, 8, 65, 228);
      set_attributes(pre, pre_data);
      toggle_class(
        pre,
        "langtag",
        /*langtag*/
        ctx[0]
      );
      toggle_class(pre, "svelte-11sh29b", true);
      add_location(pre, file, 8, 0, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, code_1);
      if_block.m(code_1, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code_1, null);
        }
      }
      set_attributes(pre, pre_data = get_spread_update(pre_levels, [
        dirty & /*languageName*/
        8 && { "data-language": (
          /*languageName*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(
        pre,
        "langtag",
        /*langtag*/
        ctx2[0]
      );
      toggle_class(pre, "svelte-11sh29b", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(pre);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["langtag", "highlighted", "code", "languageName"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LangTag", slots, []);
  let { langtag = false } = $$props;
  let { highlighted } = $$props;
  let { code } = $$props;
  let { languageName = "plaintext" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (highlighted === void 0 && !("highlighted" in $$props || $$self.$$.bound[$$self.$$.props["highlighted"]])) {
      console.warn("<LangTag> was created without expected prop 'highlighted'");
    }
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console.warn("<LangTag> was created without expected prop 'code'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("langtag" in $$new_props)
      $$invalidate(0, langtag = $$new_props.langtag);
    if ("highlighted" in $$new_props)
      $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("code" in $$new_props)
      $$invalidate(2, code = $$new_props.code);
    if ("languageName" in $$new_props)
      $$invalidate(3, languageName = $$new_props.languageName);
  };
  $$self.$capture_state = () => ({ langtag, highlighted, code, languageName });
  $$self.$inject_state = ($$new_props) => {
    if ("langtag" in $$props)
      $$invalidate(0, langtag = $$new_props.langtag);
    if ("highlighted" in $$props)
      $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("code" in $$props)
      $$invalidate(2, code = $$new_props.code);
    if ("languageName" in $$props)
      $$invalidate(3, languageName = $$new_props.languageName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [langtag, highlighted, code, languageName, $$restProps];
}
var LangTag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        langtag: 0,
        highlighted: 1,
        code: 2,
        languageName: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LangTag",
      options,
      id: create_fragment.name
    });
  }
  get langtag() {
    throw new Error("<LangTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set langtag(value) {
    throw new Error("<LangTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlighted() {
    throw new Error("<LangTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlighted(value) {
    throw new Error("<LangTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<LangTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<LangTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get languageName() {
    throw new Error("<LangTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set languageName(value) {
    throw new Error("<LangTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LangTag_default = LangTag;

// node_modules/svelte-highlight/Highlight.svelte
var get_default_slot_changes = (dirty) => ({ highlighted: dirty & /*highlighted*/
8 });
var get_default_slot_context = (ctx) => ({ highlighted: (
  /*highlighted*/
  ctx[3]
) });
function fallback_block(ctx) {
  let langtag_1;
  let current;
  const langtag_1_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { languageName: (
      /*language*/
      ctx[0].name
    ) },
    { langtag: (
      /*langtag*/
      ctx[2]
    ) },
    { highlighted: (
      /*highlighted*/
      ctx[3]
    ) },
    { code: (
      /*code*/
      ctx[1]
    ) }
  ];
  let langtag_1_props = {};
  for (let i = 0; i < langtag_1_spread_levels.length; i += 1) {
    langtag_1_props = assign(langtag_1_props, langtag_1_spread_levels[i]);
  }
  langtag_1 = new LangTag_default({ props: langtag_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(langtag_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(langtag_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(langtag_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const langtag_1_changes = dirty & /*$$restProps, language, langtag, highlighted, code*/
      31 ? get_spread_update(langtag_1_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        dirty & /*language*/
        1 && { languageName: (
          /*language*/
          ctx2[0].name
        ) },
        dirty & /*langtag*/
        4 && { langtag: (
          /*langtag*/
          ctx2[2]
        ) },
        dirty & /*highlighted*/
        8 && { highlighted: (
          /*highlighted*/
          ctx2[3]
        ) },
        dirty & /*code*/
        2 && { code: (
          /*code*/
          ctx2[1]
        ) }
      ]) : {};
      langtag_1.$set(langtag_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(langtag_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(langtag_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(langtag_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(21:20)    ",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, highlighted*/
        40)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$$restProps, language, langtag, highlighted, code*/
        31)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["language", "code", "langtag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Highlight", slots, ["default"]);
  let { language } = $$props;
  let { code } = $$props;
  let { langtag = false } = $$props;
  const dispatch = createEventDispatcher();
  let highlighted = "";
  afterUpdate(() => {
    if (highlighted)
      dispatch("highlight", { highlighted });
  });
  $$self.$$.on_mount.push(function() {
    if (language === void 0 && !("language" in $$props || $$self.$$.bound[$$self.$$.props["language"]])) {
      console.warn("<Highlight> was created without expected prop 'language'");
    }
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console.warn("<Highlight> was created without expected prop 'code'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$new_props)
      $$invalidate(1, code = $$new_props.code);
    if ("langtag" in $$new_props)
      $$invalidate(2, langtag = $$new_props.langtag);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    language,
    code,
    langtag,
    hljs: core_default,
    createEventDispatcher,
    afterUpdate,
    LangTag: LangTag_default,
    dispatch,
    highlighted
  });
  $$self.$inject_state = ($$new_props) => {
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$props)
      $$invalidate(1, code = $$new_props.code);
    if ("langtag" in $$props)
      $$invalidate(2, langtag = $$new_props.langtag);
    if ("highlighted" in $$props)
      $$invalidate(3, highlighted = $$new_props.highlighted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*language, code*/
    3) {
      $: {
        core_default.registerLanguage(language.name, language.register);
        $$invalidate(3, highlighted = core_default.highlight(code, { language: language.name }).value);
      }
    }
  };
  return [language, code, langtag, highlighted, $$restProps, $$scope, slots];
}
var Highlight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { language: 0, code: 1, langtag: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Highlight",
      options,
      id: create_fragment2.name
    });
  }
  get language() {
    throw new Error("<Highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<Highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<Highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<Highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get langtag() {
    throw new Error("<Highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set langtag(value) {
    throw new Error("<Highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Highlight_default = Highlight;

// node_modules/svelte-highlight/HighlightAuto.svelte
var get_default_slot_changes2 = (dirty) => ({ highlighted: dirty & /*highlighted*/
4 });
var get_default_slot_context2 = (ctx) => ({ highlighted: (
  /*highlighted*/
  ctx[2]
) });
function fallback_block2(ctx) {
  let langtag_1;
  let current;
  const langtag_1_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { languageName: (
      /*language*/
      ctx[3]
    ) },
    { langtag: (
      /*langtag*/
      ctx[1]
    ) },
    { highlighted: (
      /*highlighted*/
      ctx[2]
    ) },
    { code: (
      /*code*/
      ctx[0]
    ) }
  ];
  let langtag_1_props = {};
  for (let i = 0; i < langtag_1_spread_levels.length; i += 1) {
    langtag_1_props = assign(langtag_1_props, langtag_1_spread_levels[i]);
  }
  langtag_1 = new LangTag_default({ props: langtag_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(langtag_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(langtag_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(langtag_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const langtag_1_changes = dirty & /*$$restProps, language, langtag, highlighted, code*/
      31 ? get_spread_update(langtag_1_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        dirty & /*language*/
        8 && { languageName: (
          /*language*/
          ctx2[3]
        ) },
        dirty & /*langtag*/
        2 && { langtag: (
          /*langtag*/
          ctx2[1]
        ) },
        dirty & /*highlighted*/
        4 && { highlighted: (
          /*highlighted*/
          ctx2[2]
        ) },
        dirty & /*code*/
        1 && { code: (
          /*code*/
          ctx2[0]
        ) }
      ]) : {};
      langtag_1.$set(langtag_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(langtag_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(langtag_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(langtag_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(19:20)    ",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context2
  );
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, highlighted*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$$restProps, language, langtag, highlighted, code*/
        31)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["code", "langtag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HighlightAuto", slots, ["default"]);
  let { code } = $$props;
  let { langtag = false } = $$props;
  const dispatch = createEventDispatcher();
  let highlighted = "";
  let language = void 0;
  afterUpdate(() => {
    if (highlighted)
      dispatch("highlight", { highlighted, language });
  });
  $$self.$$.on_mount.push(function() {
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console.warn("<HighlightAuto> was created without expected prop 'code'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("code" in $$new_props)
      $$invalidate(0, code = $$new_props.code);
    if ("langtag" in $$new_props)
      $$invalidate(1, langtag = $$new_props.langtag);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    LangTag: LangTag_default,
    code,
    langtag,
    hljs: es_default,
    createEventDispatcher,
    afterUpdate,
    dispatch,
    highlighted,
    language
  });
  $$self.$inject_state = ($$new_props) => {
    if ("code" in $$props)
      $$invalidate(0, code = $$new_props.code);
    if ("langtag" in $$props)
      $$invalidate(1, langtag = $$new_props.langtag);
    if ("highlighted" in $$props)
      $$invalidate(2, highlighted = $$new_props.highlighted);
    if ("language" in $$props)
      $$invalidate(3, language = $$new_props.language);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*code*/
    1) {
      $:
        $$invalidate(2, { value: highlighted, language } = es_default.highlightAuto(code), highlighted, ($$invalidate(3, language), $$invalidate(0, code)));
    }
  };
  return [code, langtag, highlighted, language, $$restProps, $$scope, slots];
}
var HighlightAuto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { code: 0, langtag: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HighlightAuto",
      options,
      id: create_fragment3.name
    });
  }
  get code() {
    throw new Error("<HighlightAuto>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<HighlightAuto>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get langtag() {
    throw new Error("<HighlightAuto>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set langtag(value) {
    throw new Error("<HighlightAuto>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HighlightAuto_default = HighlightAuto;

// node_modules/svelte-highlight/HighlightSvelte.svelte
var get_default_slot_changes3 = (dirty) => ({ highlighted: dirty & /*highlighted*/
4 });
var get_default_slot_context3 = (ctx) => ({ highlighted: (
  /*highlighted*/
  ctx[2]
) });
function fallback_block3(ctx) {
  let langtag_1;
  let current;
  const langtag_1_spread_levels = [
    /*$$restProps*/
    ctx[3],
    { languageName: "svelte" },
    { langtag: (
      /*langtag*/
      ctx[1]
    ) },
    { highlighted: (
      /*highlighted*/
      ctx[2]
    ) },
    { code: (
      /*code*/
      ctx[0]
    ) }
  ];
  let langtag_1_props = {};
  for (let i = 0; i < langtag_1_spread_levels.length; i += 1) {
    langtag_1_props = assign(langtag_1_props, langtag_1_spread_levels[i]);
  }
  langtag_1 = new LangTag_default({ props: langtag_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(langtag_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(langtag_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(langtag_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const langtag_1_changes = dirty & /*$$restProps, langtag, highlighted, code*/
      15 ? get_spread_update(langtag_1_spread_levels, [
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        ),
        langtag_1_spread_levels[1],
        dirty & /*langtag*/
        2 && { langtag: (
          /*langtag*/
          ctx2[1]
        ) },
        dirty & /*highlighted*/
        4 && { highlighted: (
          /*highlighted*/
          ctx2[2]
        ) },
        dirty & /*code*/
        1 && { code: (
          /*code*/
          ctx2[0]
        ) }
      ]) : {};
      langtag_1.$set(langtag_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(langtag_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(langtag_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(langtag_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(23:20)    ",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context3
  );
  const default_slot_or_fallback = default_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, highlighted*/
        20)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$$restProps, langtag, highlighted, code*/
        15)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let highlighted;
  const omit_props_names = ["code", "langtag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HighlightSvelte", slots, ["default"]);
  let { code } = $$props;
  let { langtag = false } = $$props;
  const dispatch = createEventDispatcher();
  core_default.registerLanguage("xml", xml);
  core_default.registerLanguage("javascript", javascript);
  core_default.registerLanguage("css", css);
  afterUpdate(() => {
    if (highlighted)
      dispatch("highlight", { highlighted });
  });
  $$self.$$.on_mount.push(function() {
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console.warn("<HighlightSvelte> was created without expected prop 'code'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("code" in $$new_props)
      $$invalidate(0, code = $$new_props.code);
    if ("langtag" in $$new_props)
      $$invalidate(1, langtag = $$new_props.langtag);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    LangTag: LangTag_default,
    code,
    langtag,
    hljs: core_default,
    xml,
    javascript,
    css,
    createEventDispatcher,
    afterUpdate,
    dispatch,
    highlighted
  });
  $$self.$inject_state = ($$new_props) => {
    if ("code" in $$props)
      $$invalidate(0, code = $$new_props.code);
    if ("langtag" in $$props)
      $$invalidate(1, langtag = $$new_props.langtag);
    if ("highlighted" in $$props)
      $$invalidate(2, highlighted = $$new_props.highlighted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*code*/
    1) {
      $:
        $$invalidate(2, highlighted = core_default.highlightAuto(code).value);
    }
  };
  return [code, langtag, highlighted, $$restProps, $$scope, slots];
}
var HighlightSvelte = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { code: 0, langtag: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HighlightSvelte",
      options,
      id: create_fragment4.name
    });
  }
  get code() {
    throw new Error("<HighlightSvelte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<HighlightSvelte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get langtag() {
    throw new Error("<HighlightSvelte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set langtag(value) {
    throw new Error("<HighlightSvelte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HighlightSvelte_default = HighlightSvelte;

// node_modules/svelte-highlight/LineNumbers.svelte
var file2 = "node_modules/svelte-highlight/LineNumbers.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1vh31p0", 'pre.svelte-1vh31p0.svelte-1vh31p0{margin:0}table.svelte-1vh31p0.svelte-1vh31p0,tr.svelte-1vh31p0.svelte-1vh31p0,td.svelte-1vh31p0.svelte-1vh31p0{padding:0;border:0;margin:0;vertical-align:baseline}table.svelte-1vh31p0.svelte-1vh31p0{width:100%;border-collapse:collapse;border-spacing:0}tr.svelte-1vh31p0:first-of-type td.svelte-1vh31p0{padding-top:1em}tr.svelte-1vh31p0:last-child td.svelte-1vh31p0{padding-bottom:1em}tr.svelte-1vh31p0 td.svelte-1vh31p0:first-of-type{z-index:2}td.svelte-1vh31p0.svelte-1vh31p0{padding-left:var(--padding-left, 1em);padding-right:var(--padding-right, 1em)}td.hljs.svelte-1vh31p0.svelte-1vh31p0:not(.hideBorder):after{content:"";position:absolute;top:0;right:0;width:1px;height:100%;background:var(--border-color, currentColor)}.wrapLines.svelte-1vh31p0.svelte-1vh31p0{white-space:pre-wrap}td.svelte-1vh31p0.svelte-1vh31p0,td.svelte-1vh31p0>code.svelte-1vh31p0,pre.svelte-1vh31p0.svelte-1vh31p0{position:relative}td.svelte-1vh31p0>code.svelte-1vh31p0,pre.svelte-1vh31p0.svelte-1vh31p0{z-index:1}.line-background.svelte-1vh31p0.svelte-1vh31p0{position:absolute;z-index:0;top:0;left:0;width:100%;height:100%}tr.svelte-1vh31p0:first-of-type td .line-background.svelte-1vh31p0,tr.svelte-1vh31p0:last-of-type td .line-background.svelte-1vh31p0{height:calc(100% - 1em)}tr.svelte-1vh31p0:first-of-type td .line-background.svelte-1vh31p0{top:1em}tr.svelte-1vh31p0:last-of-type td .line-background.svelte-1vh31p0{bottom:1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGluZU51bWJlcnMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJERSxpQ0FBSSxDQUNGLE1BQU0sQ0FBRSxDQUNWLENBRUEsbUNBQUssQ0FDTCxnQ0FBRSxDQUNGLGdDQUFHLENBQ0QsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxDQUFDLENBQ1QsY0FBYyxDQUFFLFFBQ2xCLENBRUEsbUNBQU0sQ0FDSixLQUFLLENBQUUsSUFBSSxDQUNYLGVBQWUsQ0FBRSxRQUFRLENBQ3pCLGNBQWMsQ0FBRSxDQUNsQixDQUVBLGlCQUFFLGNBQWMsQ0FBQyxpQkFBRyxDQUNsQixXQUFXLENBQUUsR0FDZixDQUVBLGlCQUFFLFdBQVcsQ0FBQyxpQkFBRyxDQUNmLGNBQWMsQ0FBRSxHQUNsQixDQUVBLGlCQUFFLENBQUMsaUJBQUUsY0FBZSxDQUNsQixPQUFPLENBQUUsQ0FDWCxDQUVBLGdDQUFHLENBQ0QsWUFBWSxDQUFFLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUN0QyxhQUFhLENBQUUsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUN6QyxDQUVBLEVBQUUsbUNBQUssS0FBSyxXQUFXLENBQUMsTUFBTyxDQUM3QixPQUFPLENBQUUsRUFBRSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLENBQUMsQ0FDUixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLElBQUksY0FBYyxDQUFDLGFBQWEsQ0FDOUMsQ0FFQSx3Q0FBVyxDQUNULFdBQVcsQ0FBRSxRQUNmLENBRUEsZ0NBQUUsQ0FDRixpQkFBRSxDQUFHLG1CQUFJLENBQ1QsaUNBQUksQ0FDRixRQUFRLENBQUUsUUFDWixDQUVBLGlCQUFFLENBQUcsbUJBQUksQ0FDVCxpQ0FBSSxDQUNGLE9BQU8sQ0FBRSxDQUNYLENBRUEsOENBQWlCLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDVixDQUVBLGlCQUFFLGNBQWMsQ0FBQyxFQUFFLENBQUMsK0JBQWdCLENBQ3BDLGlCQUFFLGFBQWEsQ0FBQyxFQUFFLENBQUMsK0JBQWlCLENBQ2xDLE1BQU0sQ0FBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUN6QixDQUVBLGlCQUFFLGNBQWMsQ0FBQyxFQUFFLENBQUMsK0JBQWlCLENBQ25DLEdBQUcsQ0FBRSxHQUNQLENBRUEsaUJBQUUsYUFBYSxDQUFDLEVBQUUsQ0FBQywrQkFBaUIsQ0FDbEMsTUFBTSxDQUFFLEdBQ1YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTGluZU51bWJlcnMuc3ZlbHRlIl19 */');
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  child_ctx[13] = i;
  const constants_0 = (
    /*i*/
    child_ctx[13] + /*startingLineNumber*/
    child_ctx[2]
  );
  child_ctx[11] = constants_0;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let div;
  let style_background = `var(--highlighted-background, ${HIGHLIGHTED_BACKGROUND})`;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-1vh31p0");
      toggle_class(div, "line-background", true);
      set_style(div, "background", style_background);
      add_location(div, file2, 37, 14, 1088);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(37:12) {#if highlightedLines.includes(i)}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let style_background = `var(--highlighted-background, ${HIGHLIGHTED_BACKGROUND})`;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-1vh31p0");
      toggle_class(div, "line-background", true);
      set_style(div, "background", style_background);
      add_location(div, file2, 46, 14, 1429);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(46:12) {#if highlightedLines.includes(i)}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let tr;
  let td0;
  let code0;
  let t0_value = (
    /*lineNumber*/
    ctx[11] + ""
  );
  let t0;
  let t1;
  let show_if_1 = (
    /*highlightedLines*/
    ctx[3].includes(
      /*i*/
      ctx[13]
    )
  );
  let t2;
  let td1;
  let pre;
  let code1;
  let raw_value = (
    /*line*/
    (ctx[10] || "\n") + ""
  );
  let t3;
  let show_if = (
    /*highlightedLines*/
    ctx[3].includes(
      /*i*/
      ctx[13]
    )
  );
  let t4;
  let if_block0 = show_if_1 && create_if_block_1(ctx);
  let if_block1 = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      code0 = element("code");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      td1 = element("td");
      pre = element("pre");
      code1 = element("code");
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      code0 = claim_element(td0_nodes, "CODE", { class: true });
      var code0_nodes = children(code0);
      t0 = claim_text(code0_nodes, t0_value);
      code0_nodes.forEach(detach_dev);
      t1 = claim_space(td0_nodes);
      if (if_block0)
        if_block0.l(td0_nodes);
      td0_nodes.forEach(detach_dev);
      t2 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      pre = claim_element(td1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code1 = claim_element(pre_nodes, "CODE", {});
      var code1_nodes = children(code1);
      code1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      t3 = claim_space(td1_nodes);
      if (if_block1)
        if_block1.l(td1_nodes);
      td1_nodes.forEach(detach_dev);
      t4 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(code0, "class", "svelte-1vh31p0");
      set_style(code0, "color", `var(--line-number-color, currentColor)`);
      add_location(code0, file2, 33, 12, 920);
      attr_dev(td0, "class", "svelte-1vh31p0");
      toggle_class(td0, "hljs", true);
      toggle_class(
        td0,
        "hideBorder",
        /*hideBorder*/
        ctx[0]
      );
      set_style(td0, "position", `sticky`);
      set_style(td0, "left", `0`);
      set_style(td0, "text-align", `right`);
      set_style(td0, "user-select", `none`);
      set_style(
        td0,
        "width",
        /*width*/
        ctx[5] + "px"
      );
      add_location(td0, file2, 24, 10, 657);
      add_location(code1, file2, 44, 33, 1328);
      attr_dev(pre, "class", "svelte-1vh31p0");
      toggle_class(
        pre,
        "wrapLines",
        /*wrapLines*/
        ctx[1]
      );
      add_location(pre, file2, 44, 12, 1307);
      attr_dev(td1, "class", "svelte-1vh31p0");
      add_location(td1, file2, 43, 10, 1290);
      attr_dev(tr, "class", "svelte-1vh31p0");
      add_location(tr, file2, 23, 8, 642);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      append_hydration_dev(td0, code0);
      append_hydration_dev(code0, t0);
      append_hydration_dev(td0, t1);
      if (if_block0)
        if_block0.m(td0, null);
      append_hydration_dev(tr, t2);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, pre);
      append_hydration_dev(pre, code1);
      code1.innerHTML = raw_value;
      append_hydration_dev(td1, t3);
      if (if_block1)
        if_block1.m(td1, null);
      append_hydration_dev(tr, t4);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*startingLineNumber*/
      4 && t0_value !== (t0_value = /*lineNumber*/
      ctx2[11] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*highlightedLines*/
      8)
        show_if_1 = /*highlightedLines*/
        ctx2[3].includes(
          /*i*/
          ctx2[13]
        );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(td0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*hideBorder*/
      1) {
        toggle_class(
          td0,
          "hideBorder",
          /*hideBorder*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      32) {
        set_style(
          td0,
          "width",
          /*width*/
          ctx2[5] + "px"
        );
      }
      if (dirty & /*lines*/
      16 && raw_value !== (raw_value = /*line*/
      (ctx2[10] || "\n") + ""))
        code1.innerHTML = raw_value;
      ;
      if (dirty & /*wrapLines*/
      2) {
        toggle_class(
          pre,
          "wrapLines",
          /*wrapLines*/
          ctx2[1]
        );
      }
      if (dirty & /*highlightedLines*/
      8)
        show_if = /*highlightedLines*/
        ctx2[3].includes(
          /*i*/
          ctx2[13]
        );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(td1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:6) {#each lines as line, i}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let table;
  let tbody;
  let each_value = (
    /*lines*/
    ctx[4]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(tbody, "hljs", true);
      add_location(tbody, file2, 20, 4, 524);
      attr_dev(table, "class", "svelte-1vh31p0");
      add_location(table, file2, 19, 2, 512);
      set_attributes(div, div_data);
      set_style(div, "overflow-x", `auto`);
      toggle_class(div, "svelte-1vh31p0", true);
      add_location(div, file2, 18, 0, 463);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*HIGHLIGHTED_BACKGROUND, highlightedLines, wrapLines, lines, hideBorder, width, startingLineNumber*/
      63) {
        each_value = /*lines*/
        ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      64 && /*$$restProps*/
      ctx2[6]]));
      set_style(div, "overflow-x", `auto`);
      toggle_class(div, "svelte-1vh31p0", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DIGIT_WIDTH = 12;
var MIN_DIGITS = 2;
var HIGHLIGHTED_BACKGROUND = "rgba(254, 241, 96, 0.2)";
function instance5($$self, $$props, $$invalidate) {
  let lines;
  let len_digits;
  let len;
  let width;
  const omit_props_names = ["highlighted", "hideBorder", "wrapLines", "startingLineNumber", "highlightedLines"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineNumbers", slots, []);
  let { highlighted } = $$props;
  let { hideBorder = false } = $$props;
  let { wrapLines = false } = $$props;
  let { startingLineNumber = 1 } = $$props;
  let { highlightedLines = [] } = $$props;
  $$self.$$.on_mount.push(function() {
    if (highlighted === void 0 && !("highlighted" in $$props || $$self.$$.bound[$$self.$$.props["highlighted"]])) {
      console.warn("<LineNumbers> was created without expected prop 'highlighted'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("highlighted" in $$new_props)
      $$invalidate(7, highlighted = $$new_props.highlighted);
    if ("hideBorder" in $$new_props)
      $$invalidate(0, hideBorder = $$new_props.hideBorder);
    if ("wrapLines" in $$new_props)
      $$invalidate(1, wrapLines = $$new_props.wrapLines);
    if ("startingLineNumber" in $$new_props)
      $$invalidate(2, startingLineNumber = $$new_props.startingLineNumber);
    if ("highlightedLines" in $$new_props)
      $$invalidate(3, highlightedLines = $$new_props.highlightedLines);
  };
  $$self.$capture_state = () => ({
    highlighted,
    hideBorder,
    wrapLines,
    startingLineNumber,
    highlightedLines,
    DIGIT_WIDTH,
    MIN_DIGITS,
    HIGHLIGHTED_BACKGROUND,
    len,
    width,
    len_digits,
    lines
  });
  $$self.$inject_state = ($$new_props) => {
    if ("highlighted" in $$props)
      $$invalidate(7, highlighted = $$new_props.highlighted);
    if ("hideBorder" in $$props)
      $$invalidate(0, hideBorder = $$new_props.hideBorder);
    if ("wrapLines" in $$props)
      $$invalidate(1, wrapLines = $$new_props.wrapLines);
    if ("startingLineNumber" in $$props)
      $$invalidate(2, startingLineNumber = $$new_props.startingLineNumber);
    if ("highlightedLines" in $$props)
      $$invalidate(3, highlightedLines = $$new_props.highlightedLines);
    if ("len" in $$props)
      $$invalidate(8, len = $$new_props.len);
    if ("width" in $$props)
      $$invalidate(5, width = $$new_props.width);
    if ("len_digits" in $$props)
      $$invalidate(9, len_digits = $$new_props.len_digits);
    if ("lines" in $$props)
      $$invalidate(4, lines = $$new_props.lines);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*highlighted*/
    128) {
      $:
        $$invalidate(4, lines = highlighted.split("\n"));
    }
    if ($$self.$$.dirty & /*lines*/
    16) {
      $:
        $$invalidate(9, len_digits = lines.length.toString().length);
    }
    if ($$self.$$.dirty & /*len_digits*/
    512) {
      $:
        $$invalidate(8, len = len_digits - MIN_DIGITS < 1 ? MIN_DIGITS : len_digits);
    }
    if ($$self.$$.dirty & /*len*/
    256) {
      $:
        $$invalidate(5, width = len * DIGIT_WIDTH);
    }
  };
  return [
    hideBorder,
    wrapLines,
    startingLineNumber,
    highlightedLines,
    lines,
    width,
    $$restProps,
    highlighted,
    len,
    len_digits
  ];
}
var LineNumbers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        highlighted: 7,
        hideBorder: 0,
        wrapLines: 1,
        startingLineNumber: 2,
        highlightedLines: 3
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineNumbers",
      options,
      id: create_fragment5.name
    });
  }
  get highlighted() {
    throw new Error("<LineNumbers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlighted(value) {
    throw new Error("<LineNumbers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideBorder() {
    throw new Error("<LineNumbers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideBorder(value) {
    throw new Error("<LineNumbers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapLines() {
    throw new Error("<LineNumbers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapLines(value) {
    throw new Error("<LineNumbers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startingLineNumber() {
    throw new Error("<LineNumbers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startingLineNumber(value) {
    throw new Error("<LineNumbers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightedLines() {
    throw new Error("<LineNumbers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightedLines(value) {
    throw new Error("<LineNumbers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineNumbers_default = LineNumbers;
export {
  Highlight_default as Highlight,
  HighlightAuto_default as HighlightAuto,
  HighlightSvelte_default as HighlightSvelte,
  LineNumbers_default as LineNumbers,
  Highlight_default as default
};
//# sourceMappingURL=svelte-highlight.js.map
